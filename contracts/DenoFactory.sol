// SPDX-License-Identifier: MIT

pragma solidity 0.8.11;

library SafeMath {
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        uint256 c = a + b;
        if (c < a) return (false, 0);
        return (true, c);
    }
    }

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b > a) return (false, 0);
        return (true, a - b);
    }
    }

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (a == 0) return (true, 0);
        uint256 c = a * b;
        if (c / a != b) return (false, 0);
        return (true, c);
    }
    }

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b == 0) return (false, 0);
        return (true, a / b);
    }
    }

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
    unchecked {
        if (b == 0) return (false, 0);
        return (true, a % b);
    }
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    unchecked {
        require(b <= a, errorMessage);
        return a - b;
    }
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    unchecked {
        require(b > 0, errorMessage);
        return a / b;
    }
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
    unchecked {
        require(b > 0, errorMessage);
        return a % b;
    }
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        return account.code.length > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

library DateTimeLib {
    uint constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint constant SECONDS_PER_HOUR = 60 * 60;
    uint constant SECONDS_PER_MINUTE = 60;
    int constant OFFSET19700101 = 2440588;

    uint constant DOW_MON = 1;
    uint constant DOW_TUE = 2;
    uint constant DOW_WED = 3;
    uint constant DOW_THU = 4;
    uint constant DOW_FRI = 5;
    uint constant DOW_SAT = 6;
    uint constant DOW_SUN = 7;

    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {
        require(year >= 1970);
        int _year = int(year);
        int _month = int(month);
        int _day = int(day);

        int __days = _day
        - 32075
        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4
        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12
        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4
        - OFFSET19700101;

        _days = uint(__days);
    }
    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {
        int __days = int(_days);

        int L = __days + 68569 + OFFSET19700101;
        int N = 4 * L / 146097;
        L = L - (146097 * N + 3) / 4;
        int _year = 4000 * (L + 1) / 1461001;
        L = L - 1461 * _year / 4 + 31;
        int _month = 80 * L / 2447;
        int _day = L - 2447 * _month / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;

        year = uint(_year);
        month = uint(_month);
        day = uint(_day);
    }
    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
    }
    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;
    }
    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
        secs = secs % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
        second = secs % SECONDS_PER_MINUTE;
    }
    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {
        valid = false;
        if (year >= 1970 && month > 0 && month <= 12) {
            uint daysInMonth = _getDaysInMonth(year, month);
            if (day > 0 && day <= daysInMonth) {
                valid = true;
            }
        }
    }
    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {
        valid = false;
        if (isValidDate(year, month, day)) {
            if (hour < 24 && minute < 60 && second < 60) {
                valid = true;
            }
        }
    }
    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {
        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
        leapYear = _isLeapYear(year);
    }
    function _isLeapYear(uint year) internal pure returns (bool leapYear) {
        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }
    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {
        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
    }
    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {
        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
    }
    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {
        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
        daysInMonth = _getDaysInMonth(year, month);
    }
    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            daysInMonth = 31;
        } else if (month != 2) {
            daysInMonth = 30;
        } else {
            daysInMonth = _isLeapYear(year) ? 29 : 28;
        }
    }
    // 1 = Monday, 7 = Sunday
    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {
        uint _days = timestamp / SECONDS_PER_DAY;
        dayOfWeek = (_days + 3) % 7 + 1;
    }
    function getYear(uint timestamp) internal pure returns (uint year) {
        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getMonth(uint timestamp) internal pure returns (uint month) {
        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getDay(uint timestamp) internal pure returns (uint day) {
        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }
    function getHour(uint timestamp) internal pure returns (uint hour) {
        uint secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
    }
    function getMinute(uint timestamp) internal pure returns (uint minute) {
        uint secs = timestamp % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
    }
    function getSecond(uint timestamp) internal pure returns (uint second) {
        second = timestamp % SECONDS_PER_MINUTE;
    }
    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year += _years;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        month += _months;
        year += (month - 1) / 12;
        month = (month - 1) % 12 + 1;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _days * SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }
    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
        require(newTimestamp >= timestamp);
    }
    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp >= timestamp);
    }
    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp + _seconds;
        require(newTimestamp >= timestamp);
    }
    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year -= _years;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {
        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint yearMonth = year * 12 + (month - 1) - _months;
        year = yearMonth / 12;
        month = yearMonth % 12 + 1;
        uint daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _days * SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }
    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
        require(newTimestamp <= timestamp);
    }
    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp <= timestamp);
    }
    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {
        newTimestamp = timestamp - _seconds;
        require(newTimestamp <= timestamp);
    }
    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {
        require(fromTimestamp <= toTimestamp);
        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _years = toYear - fromYear;
    }
    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {
        require(fromTimestamp <= toTimestamp);
        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
    }
    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {
        require(fromTimestamp <= toTimestamp);
        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
    }
    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {
        require(fromTimestamp <= toTimestamp);
        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
    }
    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {
        require(fromTimestamp <= toTimestamp);
        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
    }
    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {
        require(fromTimestamp <= toTimestamp);
        _seconds = toTimestamp - fromTimestamp;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

abstract contract Pausable is Context {
    event Paused(address account);

    event Unpaused(address account);

    bool private _paused;

    constructor() {
        _paused = false;
    }

    function paused() public view virtual returns (bool) {
        return _paused;
    }

    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

interface IToken {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    function decimals() external pure returns (uint8);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface ILedger {
    function owner() external view returns (address);
    function addTracker(uint256 code_) external returns (address);
    function getTrackerAddress(uint256 code_) external returns (address);
    function getTrackerBalance(address address_, address account_) external view returns (uint256);
    function getTrackerSupply(address address_) external returns (uint256);

    function getTrackerFieldString(address address_, string memory key_) external view returns (string memory);
    function getTrackerFieldNumber(address address_, string memory key_) external view returns (uint256);
    function getTrackerFieldAddress(address address_, string memory key_) external view returns (address);

    function setTrackerFieldString(address address_, string memory key_, string memory value_) external;
    function setTrackerFieldNumber(address address_, string memory key_, uint256 value_) external;
    function setTrackerFieldAddress(address address_, string memory key_, address value_) external;

    function increaseBalance(address address_, address account_, uint256 balance_) external returns (uint256);
    function decreaseBalance(address address_, address account_, uint256 balance_) external returns (uint256);

    function listTracker(uint limit_, uint page_) external view returns (address[] memory);
    function listTrx(uint256 code_, address account_) external view returns (
        uint256[] memory, uint256[] memory, uint256[] memory
    );
    function transferOwnership(address newOwner) external;
}

contract DenoFactory is Context, Pausable, Ownable {
    using SafeMath for uint256;
    using Address for address;
    using DateTimeLib for uint;
    uint256 private constant MAX = ~uint256(0);

    mapping(address => mapping(address => uint256)) private _balances;
    mapping(address => mapping(address => uint256)) private _lockedUntils;
    mapping(address => mapping(address => uint256)) private _lockedBalances;

    mapping(address => address) public _ledgerMap;
    address[] public _ledgerList;

    constructor() {}

    function uintToStr(uint256 value) internal pure returns (string memory str){
        if (value == 0) return "0";
        uint256 j = value;
        uint256 length;
        while (j != 0){
            length++;
            j /= 10;
        }
        bytes memory bStr = new bytes(length);
        uint256 k = length;
        j = value;
        while (j != 0){
            bStr[--k] = bytes1(uint8(48 + j % 10));
            j /= 10;
        }
        str = string(bStr);
    }
    function dateToTimestamp(uint year, uint month, uint day, uint hour, uint minute) private pure returns (uint256) {
        bool valid = DateTimeLib.isValidDate(year, month, day);
        if (valid){
            return uint256(DateTimeLib.timestampFromDateTime(year, month, day, hour, minute, 0));
        }
        return 0;
    }
    function timestampToDate(uint timestamp) private pure returns (string memory) {
        (uint year, uint month, uint day, uint hour, uint minute, ) = DateTimeLib.timestampToDateTime(timestamp);

        string memory sYear = uintToStr(uint256(year));
        string memory sMonth = uintToStr(uint256(month));
        string memory sDay = uintToStr(uint256(day));
        string memory sHour = uintToStr(uint256(hour));
        string memory sMinute = uintToStr(uint256(minute));

        return string(abi.encodePacked(sYear, "-", sMonth, "-", sDay, " ", sHour, ":", sMinute));
    }

    /* Transactions Functions */
    function balanceOf(address address_, address account_) public view returns (uint256) {
        return _balances[address_][account_];
    }
    function myBalance(address address_) public view returns (uint256) {
        return _balances[address_][_msgSender()];
    }
    function lockedBalance(address address_, address account_) public view returns (uint256) {
        return _lockedBalances[address_][account_];
    }
    function myLockedBalance(address address_) public view returns (uint256) {
        return _lockedBalances[address_][_msgSender()];
    }
    function _freeBalance(address address_, address account_) private returns (uint256) {
        uint256 allBalance_ = _balances[address_][account_];
        uint256 lockedUntil_ = _lockedUntils[address_][account_];
        uint256 lockedBalance_ = _lockedBalances[address_][account_];

        uint256 free = 0;
        if (block.timestamp >= lockedUntil_) {
            _lockedBalances[address_][account_] = 0;
            free = allBalance_;
        } else {
            free = allBalance_.sub(lockedBalance_);
        }

        return free;
    }
    function _depositToken(address address_, uint256 amount_) internal whenNotPaused returns (uint256)  {
        require(amount_ >= 0, "ERC20: insufficient balance");
        IToken(address_).transferFrom(_msgSender(), address(this), amount_);
        _balances[address_][_msgSender()] = _balances[address_][_msgSender()].add(amount_);
        return _balances[address_][_msgSender()];
    }
    function _sendToken(address address_, uint256 amount_, address recipient_) internal whenNotPaused returns (uint256) {
        address account_ = _msgSender();
        uint256 freeBalance_ = _freeBalance(address_, account_);
        require(freeBalance_ >= amount_, "ERC20: insufficient balance");
        IToken(address_).transfer(recipient_, amount_);
        _balances[address_][account_] = _balances[address_][account_].sub(amount_);
        return _balances[address_][account_];
    }
    function _spendToken(address address_, uint256 amount_, address recipient_) internal whenNotPaused returns (uint256) {
        require(recipient_ != address(0), "ERC20: transfer to the zero address");
        address account_ = _msgSender();
        uint256 freeBal = _freeBalance(address_, account_);
        if (freeBal < amount_) {
            uint256 newAmount = amount_.sub(freeBal);
            _depositToken(address_, newAmount);
        }
        uint256 oldBal = _balances[address_][account_];
        uint256 newBal = _sendToken(address_, amount_, recipient_);
        uint256 spendBal = oldBal.sub(newBal);
        return spendBal;
    }
    function deposit(address address_, uint256 amount_) public returns (uint256) {
        return _depositToken(address_, amount_);
    }
    function send(address address_, uint256 amount_, address recipient_) public returns (uint256) {
        return _sendToken(address_, amount_, recipient_);
    }
    function spend(address address_, uint256 amount_, address recipient_) public returns (uint256) {
        return _spendToken(address_, amount_, recipient_);
    }
    function withdraw(address address_, uint256 amount_) public returns (uint256) {
        address account_ = _msgSender();
        uint256 balance_ = _freeBalance(address_, account_);
        require(balance_ >= amount_, "ERC20: insufficient balance");
        return _sendToken(address_, amount_, account_);
    }
    function withdrawAll(address address_) public returns (uint256) {
        address account_ = _msgSender();
        uint256 amount_ = _freeBalance(address_, account_);
        require(amount_ >= 0, "ERC20: insufficient balance");
        return _sendToken(address_, amount_, account_);
    }

    /* Lock Functions */
    function lock(address address_, uint256 amount_, uint year_, uint month_, uint day_, uint hour_, uint minute_) public {
        address account_ = _msgSender();
        uint256 balance_ = _balances[address_][account_];
        uint256 lockedUntil_ = _lockedUntils[address_][account_];
        require(balance_ >= amount_, "ERC20: insufficient balance");
        uint256 until_ = dateToTimestamp(year_, month_, day_, hour_, minute_);
        require(until_ >= block.timestamp, "ERC20: Change to newer date time");
        require(until_ >= lockedUntil_, "ERC20: Relocking only allowed beyond current lock period");

        _lockedUntils[address_][account_] = until_;
        _lockedBalances[address_][account_] = amount_;
    }
    function lockAll(address address_, uint year_, uint month_, uint day_, uint hour_, uint minute_) public {
        address account_ = _msgSender();
        uint256 balance_ = _balances[address_][account_];
        uint256 lockedUntil_ = _lockedUntils[address_][account_];
        uint256 until_ = dateToTimestamp(year_, month_, day_, hour_, minute_);
        require(until_ >= lockedUntil_, "ERC20: Relocking only allowed beyond current lock period");

        _lockedUntils[address_][account_] = until_;
        _lockedBalances[address_][account_] = balance_;
    }
    function unlockDate(address address_) public view returns (string memory) {
        address account_ = _msgSender();
        uint256 lockedUntil_ = _lockedUntils[address_][account_];
        return timestampToDate(uint256(lockedUntil_));
    }

    /* Ledger Functions */
    function addLedger(address address_, address pool_) public onlyOwner returns (bool) {
        _ledgerMap[address_] = pool_;
        uint rowCount = _ledgerList.length;
        bool blnInsert = true;
        if (rowCount > 0){
            for (uint i = 0; i < rowCount; i++) {
                if ( _ledgerList[i] == address_){
                    blnInsert = false;
                    break;
                }
            }
        }
        if (blnInsert) {
            _ledgerList.push(address_);
        }
        return blnInsert;
    }
    function deleteLedger(address address_) public onlyOwner {
        _ledgerMap[address_] = address(0);
        uint rowCount = _ledgerList.length;
        if (rowCount > 0){
            for (uint i = 0; i < rowCount; i++) {
                if ( _ledgerList[i] == address_){
                    delete _ledgerList[i];
                    break;
                }
            }
        }
    }
    function getLedgerPool(address address_) public view returns (address) {
        return _ledgerMap[address_];
    }
    function setLedgerPool(address address_, address payable pool_) public virtual onlyOwner {
        _ledgerMap[address_] = pool_;
    }
    function listLedger() public view returns (address[] memory) {
        uint rowCount = _ledgerList.length;
        address[] memory _ledgers = new address[](rowCount);
        if (rowCount > 0){
            for (uint i = 0; i < rowCount; i++) {
                _ledgers[i] = _ledgerList[i];
            }
        }
        return _ledgers;
    }

    receive() external payable {}
}
